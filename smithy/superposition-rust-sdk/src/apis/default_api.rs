/*
 * Superposition
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2025-03-05
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`conclude_experiment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConcludeExperimentError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateContextError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_default_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDefaultConfigError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dimension`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDimensionError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_experiment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateExperimentError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_function`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFunctionError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_type_templates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTypeTemplatesError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_workspace`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWorkspaceError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`creater_organisation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreaterOrganisationError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_default_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDefaultConfigError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_dimension`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDimensionError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_function`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFunctionError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_type_templates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTypeTemplatesError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`discard_experiment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DiscardExperimentError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContextError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_context_from_condition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetContextFromConditionError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_experiment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetExperimentError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_function`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFunctionError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_organisation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrganisationError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_type_templates_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTypeTemplatesListError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_contexts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListContextsError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_default_configs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDefaultConfigsError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_dimensions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDimensionsError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_experiment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListExperimentError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_organisation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListOrganisationError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_workspace`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListWorkspaceError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`move_context`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MoveContextError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`publish`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublishError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ramp_experiment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RampExperimentError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`test`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TestError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_default_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDefaultConfigError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_dimension`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDimensionError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_function`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFunctionError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_organisation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOrganisationError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_override`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOverrideError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_overrides_experiment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOverridesExperimentError {
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_type_templates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTypeTemplatesError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_workspace`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWorkspaceError {
    Status404(),
    Status500(models::InternalServerErrorResponseContent),
    UnknownValue(serde_json::Value),
}


pub async fn conclude_experiment(configuration: &configuration::Configuration, id: &str, x_org_id: &str, x_tenant: &str, conclude_experiment_request_content: models::ConcludeExperimentRequestContent) -> Result<models::ConcludeExperimentResponseContent, Error<ConcludeExperimentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_conclude_experiment_request_content = conclude_experiment_request_content;

    let uri_str = format!("{}/experiments/{id}/conclude", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_conclude_experiment_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConcludeExperimentResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConcludeExperimentResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConcludeExperimentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_context(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, create_context_request_content: models::CreateContextRequestContent, x_config_tags: Option<&str>) -> Result<models::CreateContextResponseContent, Error<CreateContextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_create_context_request_content = create_context_request_content;
    let p_x_config_tags = x_config_tags;

    let uri_str = format!("{}/context/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_config_tags {
        req_builder = req_builder.header("x-config-tags", param_value.to_string());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_context_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateContextResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateContextResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateContextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_default_config(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, create_default_config_request_content: models::CreateDefaultConfigRequestContent) -> Result<models::CreateDefaultConfigResponseContent, Error<CreateDefaultConfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_create_default_config_request_content = create_default_config_request_content;

    let uri_str = format!("{}/default-config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_default_config_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateDefaultConfigResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateDefaultConfigResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateDefaultConfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_dimension(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, create_dimension_request_content: models::CreateDimensionRequestContent) -> Result<models::CreateDimensionResponseContent, Error<CreateDimensionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_create_dimension_request_content = create_dimension_request_content;

    let uri_str = format!("{}/dimension", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_dimension_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateDimensionResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateDimensionResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateDimensionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_experiment(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, create_experiment_request_content: models::CreateExperimentRequestContent) -> Result<models::CreateExperimentResponseContent, Error<CreateExperimentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_create_experiment_request_content = create_experiment_request_content;

    let uri_str = format!("{}/experiments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_experiment_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateExperimentResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateExperimentResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateExperimentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_function(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, create_function_request_content: models::CreateFunctionRequestContent) -> Result<models::CreateFunctionResponseContent, Error<CreateFunctionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_create_function_request_content = create_function_request_content;

    let uri_str = format!("{}/function", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_function_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateFunctionResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateFunctionResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateFunctionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_type_templates(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, create_type_templates_request_content: models::CreateTypeTemplatesRequestContent) -> Result<models::CreateTypeTemplatesResponseContent, Error<CreateTypeTemplatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_create_type_templates_request_content = create_type_templates_request_content;

    let uri_str = format!("{}/types", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_type_templates_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateTypeTemplatesResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateTypeTemplatesResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTypeTemplatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_workspace(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, create_workspace_request_content: models::CreateWorkspaceRequestContent) -> Result<models::CreateWorkspaceResponseContent, Error<CreateWorkspaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_create_workspace_request_content = create_workspace_request_content;

    let uri_str = format!("{}/workspaces", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_create_workspace_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateWorkspaceResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateWorkspaceResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateWorkspaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn creater_organisation(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, creater_organisation_request_content: models::CreaterOrganisationRequestContent) -> Result<models::CreaterOrganisationResponseContent, Error<CreaterOrganisationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_creater_organisation_request_content = creater_organisation_request_content;

    let uri_str = format!("{}/superposition/organisations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_creater_organisation_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreaterOrganisationResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreaterOrganisationResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreaterOrganisationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_default_config(configuration: &configuration::Configuration, key: &str, x_org_id: &str, x_tenant: &str) -> Result<(), Error<DeleteDefaultConfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_key = key;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;

    let uri_str = format!("{}/default-config/{key}", configuration.base_path, key=crate::apis::urlencode(p_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteDefaultConfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_dimension(configuration: &configuration::Configuration, dimension: &str, x_org_id: &str, x_tenant: &str) -> Result<(), Error<DeleteDimensionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_dimension = dimension;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;

    let uri_str = format!("{}/dimension/{dimension}", configuration.base_path, dimension=crate::apis::urlencode(p_dimension));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteDimensionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_function(configuration: &configuration::Configuration, function_name: &str, x_org_id: &str, x_tenant: &str) -> Result<(), Error<DeleteFunctionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_function_name = function_name;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;

    let uri_str = format!("{}/function/{function_name}", configuration.base_path, function_name=crate::apis::urlencode(p_function_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteFunctionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_type_templates(configuration: &configuration::Configuration, type_name: &str, x_org_id: &str, x_tenant: &str) -> Result<(), Error<DeleteTypeTemplatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type_name = type_name;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;

    let uri_str = format!("{}/types/{type_name}", configuration.base_path, type_name=crate::apis::urlencode(p_type_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteTypeTemplatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn discard_experiment(configuration: &configuration::Configuration, id: &str, x_org_id: &str, x_tenant: &str, discard_experiment_request_content: models::DiscardExperimentRequestContent) -> Result<models::DiscardExperimentResponseContent, Error<DiscardExperimentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_discard_experiment_request_content = discard_experiment_request_content;

    let uri_str = format!("{}/experiments/{id}/discard", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_discard_experiment_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DiscardExperimentResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DiscardExperimentResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DiscardExperimentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_context(configuration: &configuration::Configuration, id: &str, x_org_id: &str, x_tenant: &str) -> Result<models::GetContextResponseContent, Error<GetContextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;

    let uri_str = format!("{}/context/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetContextResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetContextResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetContextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_context_from_condition(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, body: Option<serde_json::Value>) -> Result<models::GetContextFromConditionResponseContent, Error<GetContextFromConditionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_body = body;

    let uri_str = format!("{}/context/get", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetContextFromConditionResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetContextFromConditionResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetContextFromConditionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_experiment(configuration: &configuration::Configuration, id: &str, x_org_id: &str, x_tenant: &str) -> Result<models::GetExperimentResponseContent, Error<GetExperimentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;

    let uri_str = format!("{}/experiments/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetExperimentResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetExperimentResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetExperimentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_function(configuration: &configuration::Configuration, function_name: &str, x_org_id: &str, x_tenant: &str) -> Result<models::GetFunctionResponseContent, Error<GetFunctionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_function_name = function_name;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;

    let uri_str = format!("{}/function/{function_name}", configuration.base_path, function_name=crate::apis::urlencode(p_function_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFunctionResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFunctionResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFunctionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_organisation(configuration: &configuration::Configuration, id: &str, x_org_id: &str, x_tenant: &str) -> Result<models::GetOrganisationResponseContent, Error<GetOrganisationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;

    let uri_str = format!("{}/superposition/organisations/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetOrganisationResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetOrganisationResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrganisationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_type_templates_list(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, page: Option<f64>, count: Option<f64>, all: Option<bool>) -> Result<models::GetTypeTemplatesListResponseContent, Error<GetTypeTemplatesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_page = page;
    let p_count = count;
    let p_all = all;

    let uri_str = format!("{}/types", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTypeTemplatesListResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTypeTemplatesListResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetTypeTemplatesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_contexts(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, page: Option<f64>, size: Option<f64>, prefix: Option<&str>, sort_on: Option<models::ContextFilterSortOn>, sort_by: Option<models::SortBy>, created_by: Option<&str>) -> Result<models::ListContextsResponseContent, Error<ListContextsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_page = page;
    let p_size = size;
    let p_prefix = prefix;
    let p_sort_on = sort_on;
    let p_sort_by = sort_by;
    let p_created_by = created_by;

    let uri_str = format!("{}/context/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_prefix {
        req_builder = req_builder.query(&[("prefix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_on {
        req_builder = req_builder.query(&[("sort_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_created_by {
        req_builder = req_builder.query(&[("created_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListContextsResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListContextsResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListContextsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_default_configs(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, count: Option<f64>, page: Option<f64>) -> Result<models::ListDefaultConfigsResponseContent, Error<ListDefaultConfigsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_count = count;
    let p_page = page;

    let uri_str = format!("{}/default-config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListDefaultConfigsResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListDefaultConfigsResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListDefaultConfigsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_dimensions(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, count: Option<f64>, page: Option<f64>) -> Result<models::ListDimensionsResponseContent, Error<ListDimensionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_count = count;
    let p_page = page;

    let uri_str = format!("{}/dimension", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListDimensionsResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListDimensionsResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListDimensionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_experiment(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, page: Option<f64>, count: Option<f64>, all: Option<bool>) -> Result<models::ListExperimentResponseContent, Error<ListExperimentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_page = page;
    let p_count = count;
    let p_all = all;

    let uri_str = format!("{}/experiments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListExperimentResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListExperimentResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListExperimentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_organisation(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, page: Option<f64>, count: Option<f64>, all: Option<bool>) -> Result<models::ListOrganisationResponseContent, Error<ListOrganisationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_page = page;
    let p_count = count;
    let p_all = all;

    let uri_str = format!("{}/superposition/organisations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListOrganisationResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListOrganisationResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListOrganisationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn list_workspace(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, page: Option<f64>, count: Option<f64>, all: Option<bool>) -> Result<models::ListWorkspaceResponseContent, Error<ListWorkspaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_page = page;
    let p_count = count;
    let p_all = all;

    let uri_str = format!("{}/workspaces", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListWorkspaceResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListWorkspaceResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListWorkspaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn move_context(configuration: &configuration::Configuration, id: &str, x_org_id: &str, x_tenant: &str, move_context_request_content: models::MoveContextRequestContent) -> Result<models::MoveContextResponseContent, Error<MoveContextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_move_context_request_content = move_context_request_content;

    let uri_str = format!("{}/context/move/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_move_context_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MoveContextResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MoveContextResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MoveContextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn publish(configuration: &configuration::Configuration, function_name: &str, x_org_id: &str, x_tenant: &str) -> Result<models::PublishResponseContent, Error<PublishError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_function_name = function_name;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;

    let uri_str = format!("{}/function/{function_name}/publish", configuration.base_path, function_name=crate::apis::urlencode(p_function_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PublishResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PublishResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PublishError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn ramp_experiment(configuration: &configuration::Configuration, id: &str, x_org_id: &str, x_tenant: &str, ramp_experiment_request_content: models::RampExperimentRequestContent) -> Result<models::RampExperimentResponseContent, Error<RampExperimentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_ramp_experiment_request_content = ramp_experiment_request_content;

    let uri_str = format!("{}/experiments/{id}/ramp", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_ramp_experiment_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RampExperimentResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RampExperimentResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RampExperimentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn test(configuration: &configuration::Configuration, function_name: &str, stage: &str, x_org_id: &str, x_tenant: &str) -> Result<(), Error<TestError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_function_name = function_name;
    let p_stage = stage;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;

    let uri_str = format!("{}/function/{function_name}/{stage}/test", configuration.base_path, function_name=crate::apis::urlencode(p_function_name), stage=crate::apis::urlencode(p_stage));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<TestError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_default_config(configuration: &configuration::Configuration, key: &str, x_org_id: &str, x_tenant: &str, update_default_config_request_content: models::UpdateDefaultConfigRequestContent) -> Result<models::UpdateDefaultConfigResponseContent, Error<UpdateDefaultConfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_key = key;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_update_default_config_request_content = update_default_config_request_content;

    let uri_str = format!("{}/default-config/{key}", configuration.base_path, key=crate::apis::urlencode(p_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_default_config_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateDefaultConfigResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateDefaultConfigResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateDefaultConfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_dimension(configuration: &configuration::Configuration, dimension: &str, x_org_id: &str, x_tenant: &str, update_dimension_request_content: models::UpdateDimensionRequestContent) -> Result<models::UpdateDimensionResponseContent, Error<UpdateDimensionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_dimension = dimension;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_update_dimension_request_content = update_dimension_request_content;

    let uri_str = format!("{}/dimension/{dimension}", configuration.base_path, dimension=crate::apis::urlencode(p_dimension));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_dimension_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateDimensionResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateDimensionResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateDimensionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_function(configuration: &configuration::Configuration, function_name: &str, x_org_id: &str, x_tenant: &str, update_function_request_content: models::UpdateFunctionRequestContent) -> Result<models::UpdateFunctionResponseContent, Error<UpdateFunctionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_function_name = function_name;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_update_function_request_content = update_function_request_content;

    let uri_str = format!("{}/function/{function_name}", configuration.base_path, function_name=crate::apis::urlencode(p_function_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_function_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateFunctionResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateFunctionResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateFunctionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_organisation(configuration: &configuration::Configuration, id: &str, x_org_id: &str, x_tenant: &str, update_organisation_request_content: Option<models::UpdateOrganisationRequestContent>) -> Result<models::UpdateOrganisationResponseContent, Error<UpdateOrganisationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_update_organisation_request_content = update_organisation_request_content;

    let uri_str = format!("{}/superposition/organisations/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_organisation_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateOrganisationResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateOrganisationResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateOrganisationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_override(configuration: &configuration::Configuration, x_org_id: &str, x_tenant: &str, update_override_request_content: models::UpdateOverrideRequestContent, x_config_tags: Option<&str>) -> Result<models::UpdateOverrideResponseContent, Error<UpdateOverrideError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_update_override_request_content = update_override_request_content;
    let p_x_config_tags = x_config_tags;

    let uri_str = format!("{}/context/overrides", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_config_tags {
        req_builder = req_builder.header("x-config-tags", param_value.to_string());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_override_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateOverrideResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateOverrideResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateOverrideError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_overrides_experiment(configuration: &configuration::Configuration, id: &str, x_org_id: &str, x_tenant: &str, update_overrides_experiment_request_content: models::UpdateOverridesExperimentRequestContent) -> Result<models::UpdateOverridesExperimentResponseContent, Error<UpdateOverridesExperimentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_update_overrides_experiment_request_content = update_overrides_experiment_request_content;

    let uri_str = format!("{}/experiments/{id}/overrides", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_overrides_experiment_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateOverridesExperimentResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateOverridesExperimentResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateOverridesExperimentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_type_templates(configuration: &configuration::Configuration, type_name: &str, x_org_id: &str, x_tenant: &str, update_type_templates_request_content: models::UpdateTypeTemplatesRequestContent) -> Result<models::UpdateTypeTemplatesResponseContent, Error<UpdateTypeTemplatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type_name = type_name;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_update_type_templates_request_content = update_type_templates_request_content;

    let uri_str = format!("{}/types/{type_name}", configuration.base_path, type_name=crate::apis::urlencode(p_type_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_type_templates_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateTypeTemplatesResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateTypeTemplatesResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateTypeTemplatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_workspace(configuration: &configuration::Configuration, workspace_name: &str, x_org_id: &str, x_tenant: &str, update_workspace_request_content: models::UpdateWorkspaceRequestContent) -> Result<models::UpdateWorkspaceResponseContent, Error<UpdateWorkspaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workspace_name = workspace_name;
    let p_x_org_id = x_org_id;
    let p_x_tenant = x_tenant;
    let p_update_workspace_request_content = update_workspace_request_content;

    let uri_str = format!("{}/workspaces/{workspace_name}", configuration.base_path, workspace_name=crate::apis::urlencode(p_workspace_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("x-org-id", p_x_org_id.to_string());
    req_builder = req_builder.header("x-tenant", p_x_tenant.to_string());
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_workspace_request_content);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateWorkspaceResponseContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateWorkspaceResponseContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateWorkspaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

