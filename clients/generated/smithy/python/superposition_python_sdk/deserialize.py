# Code generated by smithy-python-codegen DO NOT EDIT.

from datetime import datetime
import json
from typing import Any

from smithy_core.documents import DocumentValue
from smithy_core.prelude import DOCUMENT as _SCHEMA_DOCUMENT
from smithy_core.types import TimestampFormat
from smithy_core.utils import ensure_utc, expect_type
from smithy_http.aio.interfaces import HTTPResponse
from smithy_http.aio.restjson import parse_rest_json_error_info
from smithy_json import JSONCodec

from .config import Config
from .models import (
    ApiError,
    ApplicableVariantsOutput,
    BulkOperationOut,
    BulkOperationOutput,
    ConcludeExperimentOutput,
    CreateContextOutput,
    CreateDefaultConfigOutput,
    CreateDimensionOutput,
    CreateExperimentOutput,
    CreateFunctionOutput,
    CreateOrganisationOutput,
    CreateTypeTemplatesOutput,
    CreateWebhookOutput,
    CreateWorkspaceOutput,
    DeleteContextOutput,
    DeleteDefaultConfigOutput,
    DeleteDimensionOutput,
    DeleteFunctionOutput,
    DeleteTypeTemplatesOutput,
    DiscardExperimentOutput,
    FunctionNotFound,
    GetConfigFastOutput,
    GetConfigOutput,
    GetContextFromConditionOutput,
    GetContextOutput,
    GetExperimentOutput,
    GetFunctionOutput,
    GetOrganisationOutput,
    GetResolvedConfigOutput,
    GetTypeTemplatesListOutput,
    GetWebhookOutput,
    InternalServerError,
    ListAuditLogsOutput,
    ListContextsOutput,
    ListDefaultConfigsOutput,
    ListDimensionsOutput,
    ListExperimentOutput,
    ListFunctionOutput,
    ListOrganisationOutput,
    ListVersionsOutput,
    ListWebhookOutput,
    ListWorkspaceOutput,
    MoveContextOutput,
    OrganisationNotFound,
    PauseExperimentOutput,
    PublishOutput,
    RampExperimentOutput,
    ResourceNotFound,
    ResumeExperimentOutput,
    TestOutput,
    TypeTemplatesNotFound,
    UnknownApiError,
    UpdateDefaultConfigOutput,
    UpdateDimensionOutput,
    UpdateFunctionOutput,
    UpdateOrganisationOutput,
    UpdateOverrideOutput,
    UpdateOverridesExperimentOutput,
    UpdateTypeTemplatesOutput,
    UpdateWebhookOutput,
    UpdateWorkspaceOutput,
    WebhookNotFound,
    WeightRecomputeOutput,
    WorkspaceNotFound,
)


async def _deserialize_applicable_variants(http_response: HTTPResponse, config: Config) -> ApplicableVariantsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_applicable_variants(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = ApplicableVariantsOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return ApplicableVariantsOutput(**kwargs)

async def _deserialize_error_applicable_variants(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_bulk_operation(http_response: HTTPResponse, config: Config) -> BulkOperationOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_bulk_operation(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        kwargs["bulk_operation_output"] = codec.deserialize(body, BulkOperationOut)

    return BulkOperationOutput(**kwargs)

async def _deserialize_error_bulk_operation(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_conclude_experiment(http_response: HTTPResponse, config: Config) -> ConcludeExperimentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_conclude_experiment(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = ConcludeExperimentOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return ConcludeExperimentOutput(**kwargs)

async def _deserialize_error_conclude_experiment(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_create_context(http_response: HTTPResponse, config: Config) -> CreateContextOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_context(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = CreateContextOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return CreateContextOutput(**kwargs)

async def _deserialize_error_create_context(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_create_default_config(http_response: HTTPResponse, config: Config) -> CreateDefaultConfigOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_default_config(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = CreateDefaultConfigOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return CreateDefaultConfigOutput(**kwargs)

async def _deserialize_error_create_default_config(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_create_dimension(http_response: HTTPResponse, config: Config) -> CreateDimensionOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_dimension(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = CreateDimensionOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return CreateDimensionOutput(**kwargs)

async def _deserialize_error_create_dimension(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_create_experiment(http_response: HTTPResponse, config: Config) -> CreateExperimentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_experiment(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = CreateExperimentOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return CreateExperimentOutput(**kwargs)

async def _deserialize_error_create_experiment(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_create_function(http_response: HTTPResponse, config: Config) -> CreateFunctionOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_function(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = CreateFunctionOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return CreateFunctionOutput(**kwargs)

async def _deserialize_error_create_function(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_create_organisation(http_response: HTTPResponse, config: Config) -> CreateOrganisationOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_organisation(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = CreateOrganisationOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return CreateOrganisationOutput(**kwargs)

async def _deserialize_error_create_organisation(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_create_type_templates(http_response: HTTPResponse, config: Config) -> CreateTypeTemplatesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_type_templates(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = CreateTypeTemplatesOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return CreateTypeTemplatesOutput(**kwargs)

async def _deserialize_error_create_type_templates(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_create_webhook(http_response: HTTPResponse, config: Config) -> CreateWebhookOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_webhook(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = CreateWebhookOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return CreateWebhookOutput(**kwargs)

async def _deserialize_error_create_webhook(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_create_workspace(http_response: HTTPResponse, config: Config) -> CreateWorkspaceOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_create_workspace(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = CreateWorkspaceOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return CreateWorkspaceOutput(**kwargs)

async def _deserialize_error_create_workspace(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_delete_context(http_response: HTTPResponse, config: Config) -> DeleteContextOutput:
    if http_response.status != 201 and http_response.status >= 300:
        raise await _deserialize_error_delete_context(http_response, config)

    kwargs: dict[str, Any] = {}

    return DeleteContextOutput(**kwargs)

async def _deserialize_error_delete_context(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "resourcenotfound":
            return await _deserialize_error_resource_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_delete_default_config(http_response: HTTPResponse, config: Config) -> DeleteDefaultConfigOutput:
    if http_response.status != 201 and http_response.status >= 300:
        raise await _deserialize_error_delete_default_config(http_response, config)

    kwargs: dict[str, Any] = {}

    return DeleteDefaultConfigOutput(**kwargs)

async def _deserialize_error_delete_default_config(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "resourcenotfound":
            return await _deserialize_error_resource_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_delete_dimension(http_response: HTTPResponse, config: Config) -> DeleteDimensionOutput:
    if http_response.status != 201 and http_response.status >= 300:
        raise await _deserialize_error_delete_dimension(http_response, config)

    kwargs: dict[str, Any] = {}

    return DeleteDimensionOutput(**kwargs)

async def _deserialize_error_delete_dimension(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "resourcenotfound":
            return await _deserialize_error_resource_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_delete_function(http_response: HTTPResponse, config: Config) -> DeleteFunctionOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_delete_function(http_response, config)

    kwargs: dict[str, Any] = {}

    return DeleteFunctionOutput(**kwargs)

async def _deserialize_error_delete_function(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "functionnotfound":
            return await _deserialize_error_function_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_delete_type_templates(http_response: HTTPResponse, config: Config) -> DeleteTypeTemplatesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_delete_type_templates(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = DeleteTypeTemplatesOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return DeleteTypeTemplatesOutput(**kwargs)

async def _deserialize_error_delete_type_templates(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "typetemplatesnotfound":
            return await _deserialize_error_type_templates_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_discard_experiment(http_response: HTTPResponse, config: Config) -> DiscardExperimentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_discard_experiment(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = DiscardExperimentOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return DiscardExperimentOutput(**kwargs)

async def _deserialize_error_discard_experiment(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_get_config(http_response: HTTPResponse, config: Config) -> GetConfigOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_get_config(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = GetConfigOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    for fld in http_response.fields:
        for key, value in fld.as_tuples():
            _key_lowercase = key.lower()
            match _key_lowercase:
                case "x-config-version":
                    kwargs["version"] = value

                case "last-modified":
                    kwargs["last_modified"] = ensure_utc(datetime.fromisoformat(expect_type(str, value)))

                case "x-audit-id":
                    kwargs["audit_id"] = value

                case _:
                    pass

    return GetConfigOutput(**kwargs)

async def _deserialize_error_get_config(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_get_config_fast(http_response: HTTPResponse, config: Config) -> GetConfigFastOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_get_config_fast(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        kwargs["config"] = deserializer.read_document(_SCHEMA_DOCUMENT)

    for fld in http_response.fields:
        for key, value in fld.as_tuples():
            _key_lowercase = key.lower()
            match _key_lowercase:
                case "x-config-version":
                    kwargs["version"] = value

                case "last-modified":
                    kwargs["last_modified"] = ensure_utc(datetime.fromisoformat(expect_type(str, value)))

                case "x-audit-id":
                    kwargs["audit_id"] = value

                case _:
                    pass

    return GetConfigFastOutput(**kwargs)

async def _deserialize_error_get_config_fast(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_get_context(http_response: HTTPResponse, config: Config) -> GetContextOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_get_context(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = GetContextOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return GetContextOutput(**kwargs)

async def _deserialize_error_get_context(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "resourcenotfound":
            return await _deserialize_error_resource_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_get_context_from_condition(http_response: HTTPResponse, config: Config) -> GetContextFromConditionOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_get_context_from_condition(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = GetContextFromConditionOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return GetContextFromConditionOutput(**kwargs)

async def _deserialize_error_get_context_from_condition(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "resourcenotfound":
            return await _deserialize_error_resource_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_get_experiment(http_response: HTTPResponse, config: Config) -> GetExperimentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_get_experiment(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = GetExperimentOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return GetExperimentOutput(**kwargs)

async def _deserialize_error_get_experiment(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_get_function(http_response: HTTPResponse, config: Config) -> GetFunctionOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_get_function(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = GetFunctionOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return GetFunctionOutput(**kwargs)

async def _deserialize_error_get_function(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "functionnotfound":
            return await _deserialize_error_function_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_get_organisation(http_response: HTTPResponse, config: Config) -> GetOrganisationOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_get_organisation(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = GetOrganisationOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return GetOrganisationOutput(**kwargs)

async def _deserialize_error_get_organisation(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "organisationnotfound":
            return await _deserialize_error_organisation_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_get_resolved_config(http_response: HTTPResponse, config: Config) -> GetResolvedConfigOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_get_resolved_config(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        kwargs["config"] = deserializer.read_document(_SCHEMA_DOCUMENT)

    for fld in http_response.fields:
        for key, value in fld.as_tuples():
            _key_lowercase = key.lower()
            match _key_lowercase:
                case "x-config-version":
                    kwargs["version"] = value

                case "last-modified":
                    kwargs["last_modified"] = ensure_utc(datetime.fromisoformat(expect_type(str, value)))

                case "x-audit-id":
                    kwargs["audit_id"] = value

                case _:
                    pass

    return GetResolvedConfigOutput(**kwargs)

async def _deserialize_error_get_resolved_config(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_get_type_templates_list(http_response: HTTPResponse, config: Config) -> GetTypeTemplatesListOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_get_type_templates_list(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = GetTypeTemplatesListOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return GetTypeTemplatesListOutput(**kwargs)

async def _deserialize_error_get_type_templates_list(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_get_webhook(http_response: HTTPResponse, config: Config) -> GetWebhookOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_get_webhook(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = GetWebhookOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return GetWebhookOutput(**kwargs)

async def _deserialize_error_get_webhook(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_list_audit_logs(http_response: HTTPResponse, config: Config) -> ListAuditLogsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_audit_logs(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = ListAuditLogsOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return ListAuditLogsOutput(**kwargs)

async def _deserialize_error_list_audit_logs(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_list_contexts(http_response: HTTPResponse, config: Config) -> ListContextsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_contexts(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = ListContextsOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return ListContextsOutput(**kwargs)

async def _deserialize_error_list_contexts(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_list_default_configs(http_response: HTTPResponse, config: Config) -> ListDefaultConfigsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_default_configs(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = ListDefaultConfigsOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return ListDefaultConfigsOutput(**kwargs)

async def _deserialize_error_list_default_configs(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "resourcenotfound":
            return await _deserialize_error_resource_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_list_dimensions(http_response: HTTPResponse, config: Config) -> ListDimensionsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_dimensions(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = ListDimensionsOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return ListDimensionsOutput(**kwargs)

async def _deserialize_error_list_dimensions(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_list_experiment(http_response: HTTPResponse, config: Config) -> ListExperimentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_experiment(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = ListExperimentOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return ListExperimentOutput(**kwargs)

async def _deserialize_error_list_experiment(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_list_function(http_response: HTTPResponse, config: Config) -> ListFunctionOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_function(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = ListFunctionOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return ListFunctionOutput(**kwargs)

async def _deserialize_error_list_function(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_list_organisation(http_response: HTTPResponse, config: Config) -> ListOrganisationOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_organisation(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = ListOrganisationOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return ListOrganisationOutput(**kwargs)

async def _deserialize_error_list_organisation(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_list_versions(http_response: HTTPResponse, config: Config) -> ListVersionsOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_versions(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = ListVersionsOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return ListVersionsOutput(**kwargs)

async def _deserialize_error_list_versions(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_list_webhook(http_response: HTTPResponse, config: Config) -> ListWebhookOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_webhook(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = ListWebhookOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return ListWebhookOutput(**kwargs)

async def _deserialize_error_list_webhook(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_list_workspace(http_response: HTTPResponse, config: Config) -> ListWorkspaceOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_list_workspace(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = ListWorkspaceOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return ListWorkspaceOutput(**kwargs)

async def _deserialize_error_list_workspace(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_move_context(http_response: HTTPResponse, config: Config) -> MoveContextOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_move_context(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = MoveContextOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return MoveContextOutput(**kwargs)

async def _deserialize_error_move_context(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "resourcenotfound":
            return await _deserialize_error_resource_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_pause_experiment(http_response: HTTPResponse, config: Config) -> PauseExperimentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_pause_experiment(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = PauseExperimentOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return PauseExperimentOutput(**kwargs)

async def _deserialize_error_pause_experiment(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_publish(http_response: HTTPResponse, config: Config) -> PublishOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_publish(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = PublishOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return PublishOutput(**kwargs)

async def _deserialize_error_publish(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "functionnotfound":
            return await _deserialize_error_function_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_ramp_experiment(http_response: HTTPResponse, config: Config) -> RampExperimentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_ramp_experiment(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = RampExperimentOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return RampExperimentOutput(**kwargs)

async def _deserialize_error_ramp_experiment(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_resume_experiment(http_response: HTTPResponse, config: Config) -> ResumeExperimentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_resume_experiment(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = ResumeExperimentOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return ResumeExperimentOutput(**kwargs)

async def _deserialize_error_resume_experiment(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_test(http_response: HTTPResponse, config: Config) -> TestOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_test(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = TestOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return TestOutput(**kwargs)

async def _deserialize_error_test(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "functionnotfound":
            return await _deserialize_error_function_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_update_default_config(http_response: HTTPResponse, config: Config) -> UpdateDefaultConfigOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_default_config(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = UpdateDefaultConfigOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return UpdateDefaultConfigOutput(**kwargs)

async def _deserialize_error_update_default_config(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "resourcenotfound":
            return await _deserialize_error_resource_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_update_dimension(http_response: HTTPResponse, config: Config) -> UpdateDimensionOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_dimension(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = UpdateDimensionOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return UpdateDimensionOutput(**kwargs)

async def _deserialize_error_update_dimension(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "resourcenotfound":
            return await _deserialize_error_resource_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_update_function(http_response: HTTPResponse, config: Config) -> UpdateFunctionOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_function(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = UpdateFunctionOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return UpdateFunctionOutput(**kwargs)

async def _deserialize_error_update_function(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "functionnotfound":
            return await _deserialize_error_function_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_update_organisation(http_response: HTTPResponse, config: Config) -> UpdateOrganisationOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_organisation(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = UpdateOrganisationOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return UpdateOrganisationOutput(**kwargs)

async def _deserialize_error_update_organisation(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "organisationnotfound":
            return await _deserialize_error_organisation_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_update_override(http_response: HTTPResponse, config: Config) -> UpdateOverrideOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_override(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = UpdateOverrideOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return UpdateOverrideOutput(**kwargs)

async def _deserialize_error_update_override(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "resourcenotfound":
            return await _deserialize_error_resource_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_update_overrides_experiment(http_response: HTTPResponse, config: Config) -> UpdateOverridesExperimentOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_overrides_experiment(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = UpdateOverridesExperimentOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return UpdateOverridesExperimentOutput(**kwargs)

async def _deserialize_error_update_overrides_experiment(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_update_type_templates(http_response: HTTPResponse, config: Config) -> UpdateTypeTemplatesOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_type_templates(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = UpdateTypeTemplatesOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return UpdateTypeTemplatesOutput(**kwargs)

async def _deserialize_error_update_type_templates(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "typetemplatesnotfound":
            return await _deserialize_error_type_templates_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_update_webhook(http_response: HTTPResponse, config: Config) -> UpdateWebhookOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_webhook(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = UpdateWebhookOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return UpdateWebhookOutput(**kwargs)

async def _deserialize_error_update_webhook(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "webhooknotfound":
            return await _deserialize_error_webhook_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_update_workspace(http_response: HTTPResponse, config: Config) -> UpdateWorkspaceOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_update_workspace(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = UpdateWorkspaceOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return UpdateWorkspaceOutput(**kwargs)

async def _deserialize_error_update_workspace(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case "workspacenotfound":
            return await _deserialize_error_workspace_not_found(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_weight_recompute(http_response: HTTPResponse, config: Config) -> WeightRecomputeOutput:
    if http_response.status != 200 and http_response.status >= 300:
        raise await _deserialize_error_weight_recompute(http_response, config)

    kwargs: dict[str, Any] = {}

    body = await http_response.consume_body_async()
    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = WeightRecomputeOutput.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return WeightRecomputeOutput(**kwargs)

async def _deserialize_error_weight_recompute(http_response: HTTPResponse, config: Config) -> ApiError:
    code, message, parsed_body = await parse_rest_json_error_info(http_response)

    match code.lower():
        case "internalservererror":
            return await _deserialize_error_internal_server_error(http_response, config, parsed_body, message)

        case _:
            return UnknownApiError(f"{code}: {message}")

async def _deserialize_error_function_not_found(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> FunctionNotFound:
    kwargs: dict[str, Any] = {"message": default_message}

    return FunctionNotFound(**kwargs)

async def _deserialize_error_internal_server_error(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> InternalServerError:
    kwargs: dict[str, Any] = {"message": default_message}

    if parsed_body is None:
        body = await http_response.consume_body_async()
    else:
        body = json.dumps(parsed_body).encode('utf-8')

    if body:
        codec = JSONCodec(default_timestamp_format=TimestampFormat.EPOCH_SECONDS)
        deserializer = codec.create_deserializer(body)
        body_kwargs = InternalServerError.deserialize_kwargs(deserializer)
        kwargs.update(body_kwargs)

    return InternalServerError(**kwargs)

async def _deserialize_error_organisation_not_found(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> OrganisationNotFound:
    kwargs: dict[str, Any] = {"message": default_message}

    return OrganisationNotFound(**kwargs)

async def _deserialize_error_resource_not_found(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> ResourceNotFound:
    kwargs: dict[str, Any] = {"message": default_message}

    return ResourceNotFound(**kwargs)

async def _deserialize_error_type_templates_not_found(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> TypeTemplatesNotFound:
    kwargs: dict[str, Any] = {"message": default_message}

    return TypeTemplatesNotFound(**kwargs)

async def _deserialize_error_webhook_not_found(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> WebhookNotFound:
    kwargs: dict[str, Any] = {"message": default_message}

    return WebhookNotFound(**kwargs)

async def _deserialize_error_workspace_not_found(
    http_response: HTTPResponse,
    config: Config,
    parsed_body: dict[str, DocumentValue] | None,
    default_message: str,
) -> WorkspaceNotFound:
    kwargs: dict[str, Any] = {"message": default_message}

    return WorkspaceNotFound(**kwargs)
