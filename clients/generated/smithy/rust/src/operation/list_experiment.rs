// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Orchestration and serialization glue logic for `ListExperiment`.
#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct ListExperiment;
impl ListExperiment {
    /// Creates a new `ListExperiment`
    pub fn new() -> Self {
        Self
    }
    pub(crate) async fn orchestrate(
                        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
                        input: crate::operation::list_experiment::ListExperimentInput,
                    ) -> ::std::result::Result<crate::operation::list_experiment::ListExperimentOutput, ::aws_smithy_runtime_api::client::result::SdkError<crate::operation::list_experiment::ListExperimentError, ::aws_smithy_runtime_api::client::orchestrator::HttpResponse>> {
                        let map_err = |err: ::aws_smithy_runtime_api::client::result::SdkError<::aws_smithy_runtime_api::client::interceptors::context::Error, ::aws_smithy_runtime_api::client::orchestrator::HttpResponse>| {
                            err.map_service_error(|err| {
                                err.downcast::<crate::operation::list_experiment::ListExperimentError>().expect("correct error type")
                            })
                        };
                        let context = Self::orchestrate_with_stop_point(runtime_plugins, input, ::aws_smithy_runtime::client::orchestrator::StopPoint::None)
                            .await
                            .map_err(map_err)?;
                        let output = context.finalize().map_err(map_err)?;
                        ::std::result::Result::Ok(output.downcast::<crate::operation::list_experiment::ListExperimentOutput>().expect("correct output type"))
                    }
    
                    pub(crate) async fn orchestrate_with_stop_point(
                        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
                        input: crate::operation::list_experiment::ListExperimentInput,
                        stop_point: ::aws_smithy_runtime::client::orchestrator::StopPoint,
                    ) -> ::std::result::Result<::aws_smithy_runtime_api::client::interceptors::context::InterceptorContext, ::aws_smithy_runtime_api::client::result::SdkError<::aws_smithy_runtime_api::client::interceptors::context::Error, ::aws_smithy_runtime_api::client::orchestrator::HttpResponse>> {
                        let input = ::aws_smithy_runtime_api::client::interceptors::context::Input::erase(input);
                        use ::tracing::Instrument;
                        ::aws_smithy_runtime::client::orchestrator::invoke_with_stop_point(
                            "Superposition",
                            "ListExperiment",
                            input,
                            runtime_plugins,
                            stop_point
                        )
                        // Create a parent span for the entire operation. Includes a random, internal-only,
                        // seven-digit ID for the operation orchestration so that it can be correlated in the logs.
                        .instrument(::tracing::debug_span!(
                                "Superposition.ListExperiment",
                                "rpc.service" = "Superposition",
                                "rpc.method" = "ListExperiment",
                                "sdk_invocation_id" = ::fastrand::u32(1_000_000..10_000_000),
                                
                            ))
                        .await
                    }
    
                    pub(crate) fn operation_runtime_plugins(
                        client_runtime_plugins: ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
                        client_config: &crate::config::Config,
                        config_override: ::std::option::Option<crate::config::Builder>,
                    ) -> ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins {
                        let mut runtime_plugins = client_runtime_plugins.with_operation_plugin(Self::new());
                        runtime_plugins = runtime_plugins
                                        .with_client_plugin(crate::auth_plugin::DefaultAuthOptionsPlugin::new(vec![::aws_smithy_runtime_api::client::auth::http::HTTP_BEARER_AUTH_SCHEME_ID]));
                        if let ::std::option::Option::Some(config_override) = config_override {
                            for plugin in config_override.runtime_plugins.iter().cloned() {
                                runtime_plugins = runtime_plugins.with_operation_plugin(plugin);
                            }
                            runtime_plugins = runtime_plugins.with_operation_plugin(
                                crate::config::ConfigOverrideRuntimePlugin::new(config_override, client_config.config.clone(), &client_config.runtime_components)
                            );
                        }
                        runtime_plugins
                    }
}
impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin for ListExperiment {
                fn config(&self) -> ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer> {
                    let mut cfg = ::aws_smithy_types::config_bag::Layer::new("ListExperiment");

                    cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedRequestSerializer::new(ListExperimentRequestSerializer));
                    cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedResponseDeserializer::new(ListExperimentResponseDeserializer));

                    
                    cfg.store_put(::aws_smithy_runtime_api::client::auth::AuthSchemeOptionResolverParams::new(::aws_smithy_runtime_api::client::auth::static_resolver::StaticAuthSchemeOptionResolverParams::new()));

                    cfg.store_put(::aws_smithy_runtime_api::client::orchestrator::Metadata::new(
                            "ListExperiment",
                            "Superposition",
                        ));

                    ::std::option::Option::Some(cfg.freeze())
                }

                fn runtime_components(&self, _: &::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder) -> ::std::borrow::Cow<'_, ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder> {
                    #[allow(unused_mut)]
                    let mut rcb = ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder::new("ListExperiment")
                            .with_interceptor(::aws_smithy_runtime::client::stalled_stream_protection::StalledStreamProtectionInterceptor::default())
.with_interceptor(ListExperimentEndpointParamsInterceptor)
                            .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::TransientErrorClassifier::<crate::operation::list_experiment::ListExperimentError>::new())
.with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::ModeledAsRetryableClassifier::<crate::operation::list_experiment::ListExperimentError>::new());

                    ::std::borrow::Cow::Owned(rcb)
                }
            }

            
#[derive(Debug)]
            struct ListExperimentResponseDeserializer;
            impl ::aws_smithy_runtime_api::client::ser_de::DeserializeResponse for ListExperimentResponseDeserializer {
                

                fn deserialize_nonstreaming(&self, response: &::aws_smithy_runtime_api::client::orchestrator::HttpResponse) -> ::aws_smithy_runtime_api::client::interceptors::context::OutputOrError {
                    let (success, status) = (response.status().is_success(), response.status().as_u16());
            let headers = response.headers();
            let body = response.body().bytes().expect("body loaded");
            #[allow(unused_mut)]
            let mut force_error = false;
            
            let parse_result = if !success && status != 200 || force_error {
                crate::protocol_serde::shape_list_experiment::de_list_experiment_http_error(status, headers, body)
            } else {
                crate::protocol_serde::shape_list_experiment::de_list_experiment_http_response(status, headers, body)
            };
            crate::protocol_serde::type_erase_result(parse_result)
                }
            }
#[derive(Debug)]
            struct ListExperimentRequestSerializer;
            impl ::aws_smithy_runtime_api::client::ser_de::SerializeRequest for ListExperimentRequestSerializer {
                #[allow(unused_mut, clippy::let_and_return, clippy::needless_borrow, clippy::useless_conversion)]
                fn serialize_input(&self, input: ::aws_smithy_runtime_api::client::interceptors::context::Input, _cfg: &mut ::aws_smithy_types::config_bag::ConfigBag) -> ::std::result::Result<::aws_smithy_runtime_api::client::orchestrator::HttpRequest, ::aws_smithy_runtime_api::box_error::BoxError> {
                    let input = input.downcast::<crate::operation::list_experiment::ListExperimentInput>().expect("correct type");
                    let _header_serialization_settings = _cfg.load::<crate::serialization_settings::HeaderSerializationSettings>().cloned().unwrap_or_default();
                    let mut request_builder = {
                        fn uri_base(_input: &crate::operation::list_experiment::ListExperimentInput, output: &mut ::std::string::String) -> ::std::result::Result<(), ::aws_smithy_types::error::operation::BuildError> {
    use ::std::fmt::Write as _;
    ::std::write!(output, "/experiments").expect("formatting should succeed");
    ::std::result::Result::Ok(())
}
fn uri_query(_input: &crate::operation::list_experiment::ListExperimentInput, mut output: &mut ::std::string::String) -> ::std::result::Result<(), ::aws_smithy_types::error::operation::BuildError> {
    let mut query = ::aws_smithy_http::query::Writer::new(output);
    if let ::std::option::Option::Some(inner_1) = &_input.page {
         {
            query.push_kv("page", ::aws_smithy_types::primitive::Encoder::from(*inner_1).encode());
        }
    }
    if let ::std::option::Option::Some(inner_2) = &_input.count {
         {
            query.push_kv("count", ::aws_smithy_types::primitive::Encoder::from(*inner_2).encode());
        }
    }
    if let ::std::option::Option::Some(inner_3) = &_input.all {
         {
            query.push_kv("all", ::aws_smithy_types::primitive::Encoder::from(*inner_3).encode());
        }
    }
    if let ::std::option::Option::Some(inner_4) = &_input.status {
         {
            query.push_kv("status", &::aws_smithy_http::query::fmt_string(inner_4));
        }
    }
    if let ::std::option::Option::Some(inner_5) = &_input.from_date {
         {
            query.push_kv("from_date", &::aws_smithy_http::query::fmt_timestamp(inner_5, ::aws_smithy_types::date_time::Format::DateTime)?);
        }
    }
    if let ::std::option::Option::Some(inner_6) = &_input.to_date {
         {
            query.push_kv("to_date", &::aws_smithy_http::query::fmt_timestamp(inner_6, ::aws_smithy_types::date_time::Format::DateTime)?);
        }
    }
    if let ::std::option::Option::Some(inner_7) = &_input.experiment_name {
         {
            query.push_kv("experiment_name", &::aws_smithy_http::query::fmt_string(inner_7));
        }
    }
    if let ::std::option::Option::Some(inner_8) = &_input.experiment_ids {
         {
            query.push_kv("experiment_ids", &::aws_smithy_http::query::fmt_string(inner_8));
        }
    }
    if let ::std::option::Option::Some(inner_9) = &_input.created_by {
         {
            query.push_kv("created_by", &::aws_smithy_http::query::fmt_string(inner_9));
        }
    }
    if let ::std::option::Option::Some(inner_10) = &_input.context_query {
         {
            query.push_kv("context", &::aws_smithy_http::query::fmt_string(inner_10));
        }
    }
    if let ::std::option::Option::Some(inner_11) = &_input.sort_on {
         {
            query.push_kv("sort_on", &::aws_smithy_http::query::fmt_string(inner_11));
        }
    }
    if let ::std::option::Option::Some(inner_12) = &_input.sort_by {
         {
            query.push_kv("sort_by", &::aws_smithy_http::query::fmt_string(inner_12));
        }
    }
    ::std::result::Result::Ok(())
}
#[allow(clippy::unnecessary_wraps)]
fn update_http_builder(
                input: &crate::operation::list_experiment::ListExperimentInput,
                builder: ::http::request::Builder
            ) -> ::std::result::Result<::http::request::Builder, ::aws_smithy_types::error::operation::BuildError> {
    let mut uri = ::std::string::String::new();
    uri_base(input, &mut uri)?;
    uri_query(input, &mut uri)?;
    let builder = crate::protocol_serde::shape_list_experiment::ser_list_experiment_headers(input, builder)?;
    ::std::result::Result::Ok(builder.method("GET").uri(uri))
}
let mut builder = update_http_builder(&input, ::http::request::Builder::new())?;
builder
                    };
                    let body = ::aws_smithy_types::body::SdkBody::from("");
                    
                    ::std::result::Result::Ok(request_builder.body(body).expect("valid request").try_into().unwrap())
                }
            }
#[derive(Debug)]
            struct ListExperimentEndpointParamsInterceptor;

            impl ::aws_smithy_runtime_api::client::interceptors::Intercept for ListExperimentEndpointParamsInterceptor {
                fn name(&self) -> &'static str {
                    "ListExperimentEndpointParamsInterceptor"
                }

                fn read_before_execution(
                    &self,
                    context: &::aws_smithy_runtime_api::client::interceptors::context::BeforeSerializationInterceptorContextRef<'_, ::aws_smithy_runtime_api::client::interceptors::context::Input, ::aws_smithy_runtime_api::client::interceptors::context::Output, ::aws_smithy_runtime_api::client::interceptors::context::Error>,
                    cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
                ) -> ::std::result::Result<(), ::aws_smithy_runtime_api::box_error::BoxError> {
                    let _input = context.input()
                        .downcast_ref::<ListExperimentInput>()
                        .ok_or("failed to downcast to ListExperimentInput")?;

                    

                    let params = crate::config::endpoint::Params::builder()
                        
                        .build()
                        .map_err(|err| ::aws_smithy_runtime_api::client::interceptors::error::ContextAttachedError::new("endpoint params could not be built", err))?;
                    cfg.interceptor_state().store_put(::aws_smithy_runtime_api::client::endpoint::EndpointResolverParams::new(params));
                    ::std::result::Result::Ok(())
                }
            }

            // The get_* functions below are generated from JMESPath expressions in the
            // operationContextParams trait. They target the operation's input shape.

            

/// Error type for the `ListExperimentError` operation.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListExperimentError {
    #[allow(missing_docs)] // documentation missing in model
    InternalServerError(crate::types::error::InternalServerError),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    #[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
    variable wildcard pattern and check `.code()`:
     \
    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
     \
    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-ListExperimentError) for what information is available for the error.")]
                    Unhandled(crate::error::sealed_unhandled::Unhandled),
}
impl ListExperimentError {
    /// Creates the `ListExperimentError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>) -> Self {
                        Self::Unhandled(crate::error::sealed_unhandled::Unhandled { source: err.into(), meta: ::std::default::Default::default() })
                    }
    
                    /// Creates the `ListExperimentError::Unhandled` variant from an [`ErrorMetadata`](::aws_smithy_types::error::ErrorMetadata).
                    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(crate::error::sealed_unhandled::Unhandled { source: err.clone().into(), meta: err })
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InternalServerError(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::Unhandled(e) => &e.meta,
        }
    }
    /// Returns `true` if the error kind is `ListExperimentError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
}
impl ::std::error::Error for ListExperimentError {
    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Self::InternalServerError(_inner) =>
            ::std::option::Option::Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                ::std::option::Option::Some(&*_inner.source)
            }
        }
    }
}
impl ::std::fmt::Display for ListExperimentError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::InternalServerError(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self) {
                                                        write!(f, "unhandled error ({code})")
                                                    } else {
                                                        f.write_str("unhandled error")
                                                    }
            }
        }
    }
}
impl ::aws_smithy_types::retry::ProvideErrorKind for ListExperimentError {
    fn code(&self) -> ::std::option::Option<&str> {
        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
        ::std::option::Option::None
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for ListExperimentError {
    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InternalServerError(_inner) =>
            ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                &_inner.meta
            }
        }
    }
}
impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for ListExperimentError {
    fn create_unhandled_error(
                        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
                        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>
                    ) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled { source, meta: meta.unwrap_or_default() })
    }
}

pub use crate::operation::list_experiment::_list_experiment_output::ListExperimentOutput;

pub use crate::operation::list_experiment::_list_experiment_input::ListExperimentInput;

mod _list_experiment_input;

mod _list_experiment_output;

/// Builders
pub mod builders;

