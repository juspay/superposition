>
**3. Technologies, Frameworks, and Abstractions**

This document details the technologies, frameworks, and common abstractions employed in the "Superposition" project, aiming to guide developers contributing to the codebase.

**Core Technologies:**

*   **Rust:** The primary programming language for both backend and frontend (via WebAssembly) components. This choice emphasizes performance, memory safety, and concurrency.
*   **PostgreSQL:** The relational database system used for persistent storage. Accessed via the Diesel ORM.
*   **JSON:** Extensively used for data interchange, configuration definitions (schemas, context conditions, overrides), and API request/response payloads.
*   **WebAssembly (WASM):** The Leptos frontend framework compiles Rust code to WASM for execution in the browser.
*   **Base64:** Used for encoding function code (custom logic) before storing it in the database.

**Backend Frameworks and Libraries:**

*   **Actix-web:** A powerful, pragmatic, and extremely fast web framework for Rust used to build the backend HTTP server and API endpoints.
    *   **Routing:** Defined using attribute macros (`#[get("/")]`, `#[post("/{key}")]`, etc.) on handler functions. Scopes (`web::scope("/path")`) are used to group related routes (e.g., all `/context` routes).
    *   **Request Handling:** Handler functions are typically `async` and take specific Actix-web extractor types as arguments (e.g., `web::Json<T>` for JSON payloads, `web::Path<T>` for path parameters, `web::Query<T>` for query parameters, `web::Data<AppState>` for shared application state).
    *   **Response Handling:** Handlers return `superposition::Result<HttpResponse>` or `superposition::Result<impl Responder>`. `HttpResponse` builder patterns are used to construct responses, set status codes, headers, and JSON bodies.
    *   **Middleware:**
        *   `TenantMiddlewareFactory`: Custom middleware for identifying the tenant, likely based on request headers or path segments. This is crucial for multi-tenancy.
        *   `AppExecutionScopeMiddlewareFactory`: Custom middleware to distinguish between API calls intended for the Context-Aware Configuration (CAC) subsystem versus the Experimentation subsystem (`AppScope::CAC`, `AppScope::EXPERIMENTATION`). This likely sets some context for request processing or database schema selection.
        *   `actix_web::middleware::DefaultHeaders`: Used to add common response headers like `X-SERVER-VERSION` and `Cache-Control`.
        *   Custom middleware for injecting a default `User` object into request extensions.
    *   **Shared State (`AppState`):** An `actix_web::web::Data<AppState>` object is used to share application-wide state with handlers. This `AppState` includes:
        *   Database connection pool (`PgSchemaManager`).
        *   Pre-compiled JSON schemas (e.g., `default_config_validation_schema`, `meta_schema`).
        *   Configuration values read from the environment (e.g., `cac_host`, `cac_version`, experimentation flags, tenant lists).
        *   Snowflake ID generator.
        *   Service prefix.

*   **Diesel:** The ORM (Object-Relational Mapper) and query builder used for interacting with the PostgreSQL database.
    *   **Schema Management:** A `db::schema` module (e.g., `context_aware_config/src/db/schema.rs`) is typically generated by Diesel CLI, defining table structures as Rust modules.
    *   **Models:** Structs in `db::models.rs` (e.g., `Context`, `Dimension`, `DefaultConfig`, `Function`, `TypeTemplates`, `EventLog`) are defined, deriving Diesel traits like `Queryable`, `Insertable`, `AsChangeset`. These map Rust structs to database tables.
    *   **Database Operations:**
        *   **Queries:** Built using Diesel's DSL (e.g., `.filter()`, `.select()`, `.order()`, `.limit()`, `.offset()`).
        *   **Inserts/Upserts:** `diesel::insert_into(...).values(...).execute(...)` or `.get_result(...)`. Upserts are commonly handled using `.on_conflict(...).do_update().set(...)`.
        *   **Updates:** `diesel::update(...).filter(...).set(...).execute(...)` or `.get_result(...)`.
        *   **Deletes:** `diesel::delete(...).filter(...).execute(...)`.
        *   **Transactions:** `conn.transaction(|transaction_conn| { ... })` is used extensively to ensure atomicity for complex operations, especially those involving multiple database modifications and versioning. Savepoints (`SAVEPOINT ...`, `ROLLBACK TO ...`) are used for finer-grained transaction control within bulk operations or upsert-like logic.
    *   **Connection Pooling:** `diesel::r2d2::ConnectionManager` is used with `PgSchemaManager` (from `service_utils`) to manage a pool of database connections. `DbConnection` is a type alias likely representing a `PooledConnection`.

*   **Serde:** Used for serializing and deserializing data, primarily between Rust structs and JSON for API requests/responses and for storing JSON `Value` types in the database. Traits like `Serialize` and `Deserialize` are derived for most DTOs and database models.

*   **`jsonschema` crate:** Used for validating JSON data against JSON Schema definitions.
    *   Schemas for `DefaultConfig` values, `Dimension` values, and `TypeTemplate` definitions are validated using this.
    *   A `meta_schema` (likely Draft 7) is used to validate that the schemas themselves are valid JSON schemas.

*   **`cac_client` crate:** A local client library that encapsulates the core logic for evaluating context-aware configurations (`eval_cac`, `eval_cac_with_reasoning`). This function takes default configurations, context definitions, override values, and an evaluation context (query parameters) to produce the final resolved configuration. It also handles merge strategies.

*   **Logging:**
    *   `log` crate for the logging facade.
    *   `env_logger` as the backend, configured via environment variables.
    *   Logging is used for errors, info, and debugging.

*   **Error Handling:**
    *   A custom `superposition::Result` type (likely an alias for `Result<T, superposition::AppError>`) is used throughout the API handlers.
    *   `superposition_types::AppError` seems to be a central error enum.
    *   Custom error macros (`bad_argument!`, `db_error!`, `not_found!`, `unexpected_error!`, `validation_error!`) from `superposition_macros` are used to create specific `AppError` variants with context. These often map to appropriate HTTP status codes.

**Frontend Frameworks and Libraries:**

*   **Leptos:** A full-stack Rust web framework for building declarative user interfaces that compile to WebAssembly.
    *   **Component-Based:** UI is built using components defined with the `view!` macro.
    *   **Reactivity:** Likely uses Leptos's signals for managing state and reactive updates.
    *   **Routing:** `leptos_router` is used for client-side and server-side routing. `generate_route_list` is used in `main.rs` to prepare routes for Actix.
    *   **Server Functions (`leptos_actix::handle_server_fns()`):** Leptos server functions are used for communication between the WASM frontend and the Actix backend (e.g., `/fxn/{tail:.*}` route in `main.rs`).
    *   **Static Assets:** Served by Actix (`actix-files`) from `pkg` (compiled WASM/JS) and `assets` directories.

**Common Abstractions and Patterns:**

*   **`AppState`:** Centralized shared state for Actix handlers.
*   **`DbConnection`:** A type alias abstracting pooled database connections.
*   **Service-Oriented Crates:** The codebase is modularized into crates like `context_aware_config`, `experimentation_platform`, `service_utils`, `frontend`, etc., each handling a specific domain or concern.
*   **Path Dependencies:** Crates within the workspace depend on each other using local path dependencies (`path = "../other_crate"`), typical of a monorepo setup.
*   **Workspace `Cargo.toml`:** Manages common dependencies and metadata for the entire project.
*   **Request/Response Types:** Dedicated structs for API request (`*Req`) and response (`*Resp`) payloads, often deriving `Serialize` and `Deserialize`.
*   **Database Models:** Structs that map to database tables, deriving Diesel's traits.
*   **`.endpoints()` functions:** A common pattern in API modules (e.g., `context::endpoints()`) to return an Actix `Scope` that bundles all routes for that resource.
*   **Validation:**
    *   JSON schema validation for configuration structures.
    *   Regex validation for key/name formats.
    *   Custom validation functions (e.g., in `validation_functions` module, possibly involving `caclang` or the Deno runtime for JavaScript functions).
*   **Configuration Versioning and Auditing:** Consistent pattern of updating a global configuration version (`X-Config-Version` header) and logging changes to an `event_log` table for traceability (`X-Audit-Id` header).
*   **Base64 Encoding for Function Code:** Custom function logic is stored as Base64 encoded strings.
*   **Custom Deserializers:** E.g., `deserialize_stringified_list` for handling comma-separated string lists in query parameters, and `deserialize_option` for robust optional field handling in JSON.

**Framework Rules & Conventions (Inferred):**

*   **API Design:** Follows RESTful principles with standard HTTP methods (GET, PUT, POST, PATCH, DELETE).
*   **Error Responses:** Errors are generally returned as JSON objects with a descriptive message, mapping to appropriate HTTP status codes via the custom error types and macros.
*   **Database Interaction:** Encapsulated within handler functions or dedicated helper functions, often within transactions for write operations.
*   **Modularity:** Code is organized into modules that often mirror the API resource structure (e.g., `api/context/handlers.rs`, `api/context/types.rs`).
*   **Environment Variables:** Heavily used for all external configurations (database URLs, service hosts, feature flags, tenant lists), making the application configurable for different environments.

This detailed overview should provide developers with a strong understanding of the technological landscape and common practices within the Superposition project.
